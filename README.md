# Алгоритмы STL, xrange, zip

Реализован набор stl-совместимых алгоритмов, генератор xrange и zip. Покрыты тестами.

### Алгоритмы

- **all_of** - возвращает true, если все элементы диапазона удовлетворяют некоторому предикату. Иначе false
- **any_of** - возвращает true, если хотя бы один из элементов диапазона удовлетворяет некоторому предикату. Иначе false
- **none_of** - возвращает true, если все элементы диапазона не удовлетворяют некоторому предикату. Иначе false
- **one_of** - возвращает true, если ровно один элемент диапазона удовлетворяет некоторому предикату. Иначе false
- **is_sorted** - возвращает true, если все элементы диапазона находятся в отсортированном порядке относительно некоторого критерия
- **is_partitioned** - возвращает true, если в диапазоне есть элемент, делящий все элементы на удовлетворяющие и не удовлетворяющие - некоторому предикату. Иначе false.
- **find_not** - находит первый элемент, не равный заданному
- **find_backward** - находит первый элемент, равный заданному, с конца
- **is_palindrome** - возвращает true, если заданная последовательность является палиндромом относительно некоторого условия. Иначе false.

### xrange

В питоне есть весьма полезная функция [xrange](https://docs.python.org/2/library/functions.html#xrange). Реализовать ее аналог за O(1) по памяти. Функция помогает генерировать значение из определенного диапазона с некоторым шагом.
Реализованы три сигнатуры
- xrange(start, end)
- xrange(end)
- xrange(start, end, step)

Например:

```cpp
auto x = xrange(1.5, 5.5);
std::vector<int> v{x.begin(), x.end()}; // 1.5 2.5 3.5 4.5
```

```cpp
auto x = xrange(4);
std::vector<int> v{x.begin(), x.end()}; // 0 1 2 3
```

```cpp
// 1 3 5
for(auto i : xrange(1, 6, 2)) {
    std::cout << i <<  " ";
}
```

Без указания шага, на каждой итерации генерируется инкремент к предыдущему значению, при трех параметрах - увеличивается на указанных шаг


### zip

Так же в питоне есть стандартная [функция zip](https://docs.python.org/2/library/functions.html#zip), также реализована - для 2 аргументов за O(1) по памяти. Функция генерирует пары, где i-я пара состоит из i-го числа первой и второй последовательности. Если одна последовательность короче второй, то после достижения последнего элемента более короткой последовательности генерация заканчивается, Функция поддерживает работу с любыми контейнерами поддерживающими однонаправленные итераторы.

Пример:
```c++
std::list l = {1, 2, 3, 4, 5};
std::vector v = {'a', 'b', 'c', 'd'};
/*
1 a
2 b
3 c
4 d
*/
for(auto value : zip(l, v)) {
  std::cout << value.first << " " << value.second << std::endl;
}
```
